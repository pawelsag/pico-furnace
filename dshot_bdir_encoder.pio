.program dshot_encoder

.define public BIT_PERIOD 40
.define public MIN_THROTTLE_VALUE 48
.define public MAX_THROTTLE_VALUE 2048

.define ONE_HIGH 30
.define ONE_LOW (BIT_PERIOD - ONE_HIGH)
.define ONE_HIGH_DELAY (ONE_HIGH - 1)
.define ONE_LOW_DELAY (ONE_LOW - 5)

.define ZERO_HIGH 15
.define ZERO_LOW (BIT_PERIOD - ZERO_HIGH)
.define ZERO_HIGH_DELAY (ZERO_HIGH - 1)
.define ZERO_LOW_DELAY (ZERO_LOW - 5)

// 8kHz DShot300 -> 1500 frame period -> 1500 - (BIT_PERIOD * 16 + 1) = 859 delay
// 40 * 16 + 1 = 641 // time required to send frames
// 360 + 360 = 720 // switching from send/receive mode
// 21 bits * 32 cycles = 672
// 641 + 720 + 672 == 2033  
// We need wait about 30us before reading the value
.define READ_AFTER_SEND_CYCLES 360 // 360 = 30 * 12
.define READ_AFTER_SEND_DELAY (30 - 1) // 29 + istruction exeuction time = 30
.define READ_AFTER_SEND_DELAY_TIMES 12
.define RECEIVED_PAYLOAD_LENGTH 21 // ERPM GCR returned length

init:
  ; grab MIN_THROTTLE  value from fifo and store it in scratch register
  pull block
  mov x, osr
  jmp start_frame
maybe_pull:
  pull noblock ; if fifo empty, mov osr, x will be automatically performed
  mov x, osr ; recycle value to reuse next time. In X we keep last throttle value
start_frame:
  out y, 16 ; discard 16 most significant bits, payload is only 16 bit
transmit_or_receive:
  jmp !osre transmit_bit
  jmp receive_frame
transmit_bit:
  out y, 1
  jmp !y do_zero
do_one:
  set pins, 0 [ONE_HIGH_DELAY]
  set pins, 1 [ONE_LOW_DELAY]
  jmp transmit_or_receive
do_zero:
  set pins, 0 [ZERO_HIGH_DELAY]
  set pins, 1 [ZERO_LOW_DELAY]
  jmp transmit_or_receive
receive_frame:
  set pins, 1
  set y, READ_AFTER_SEND_DELAY_TIMES
wait_for_frame:
  jmp y-- wait_for_frame [READ_AFTER_SEND_DELAY]
  set y, RECEIVED_PAYLOAD_LENGTH
  nop [5] ; delay few bits to stabilize signal from ESC
receive_telemetry:
  in pins, 1 ; read frame once frame become stable
  jmp y-- receive_telemetry [30] ; receive another bit after 2.66ns 30 + 1 + 1 == 32
push_and_wrap:
  push noblock
  jmp maybe_pull

% c-sdk {
#include "hardware/clocks.h"

static inline void bidir_dshot_encoder_program_init(PIO pio, uint sm, uint offset, uint pin) {
    pio_sm_config c = dshot_encoder_program_get_default_config(offset);

    sm_config_set_set_pins(&c, pin, 1);
    pio_gpio_init(pio, pin);
    pio_sm_set_consecutive_pindirs(pio, sm, pin, 1, true);

    sm_config_set_out_shift(&c, false, false, 32);

    double clocks_per_us = clock_get_hz(clk_sys) / 1000000;
    // 3.333us per bit for dshot300
    sm_config_set_clkdiv(&c, 3.333 / dshot_encoder_BIT_PERIOD * clocks_per_us);

    pio_sm_init(pio, sm, offset, &c);

    pio_sm_put_blocking(pio, sm, dshot_encoder_MIN_THROTTLE_VALUE);

    // The PIO will begin waiting for the first command value
    pio_sm_set_enabled(pio, sm, true);
}
%}
